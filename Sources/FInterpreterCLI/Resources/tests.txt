# 1. Literals and simple assignment
42
-7
3.14
true
null
(setq x 5) x
(setq y -10) (plus x y)

# 2. Parser and Semantic errors: invalid literals and assignment
3..14
(setq 123 456)
(setq x 5)) x
(setq)

# 3. Quote and lists
'x
'hello
(setq operations '(plus minus times divide)) operations
(setq nested '((1 2) (3 4))) nested

# 4. Semantic errors: invalid quote usage
(quote)
(quote x y)

# 5. Arithmetic operations
(plus 10 20)
(minus 15.1 7)
(times 6 8)
(divide 20 4)

# 6. Semantic errors: arithmetic type errors
(plus true 10)
(plus 1)
(divide 1 2 3)
(minus 'hello 5)
(times 2 null)

# 7. Comparisons and predicates
(less 5 10)
(less true false)
(equal 3.0 3.0)
(isint 42)
(isint true)
(isreal null)
(isreal 3.14)
(isatom 'x)
(islist '(a b c))
(isnull null)

# 8. Semantic errors: comparison type mismatches
(equal 1 'one)
(less null 5)
(less 1)
(less 1 2 3)

# 9. Head / tail / cons operations
(head '(first second third))
(tail '(head tail body))
(cons 'new '(existing list))
(cons 1 (cons 2 (cons 3 '())))

# 10. Semantic errors: list operation type errors
(head 42)
(head)
(head '(1) 2)
(tail 42)
(cons 1)
(cons true false)

# 11. Logical operators
(and true true)
(or false true)
(xor true false)
(not false)
(and (less 1 2) (greater 5 3))
(or (equal 1 2) (equal 3 3))

# 12. Semantic errors: logical operator type errors
(and 1 true)
(and true)
(and true false true)
(or 'string false)
(xor null true)
(not 42)
(not)
(not true false)

# 13. Func / lambda / function calls
(func square (x) (times x x))
(square 5)
(setq double (lambda (x) (plus x x)))
(double 10)
((lambda (x y) (times x y)) 3 4)
(func greet (name)
  (cons 'hello (cons name '())))
(greet 'world)

# 14. Semantic errors: function definition and call errors
(func 123 (x) x)
(lambda (1 2) 3)
(square 1 2 3)
((lambda (x) x))

# 15. Prog, local scope and return
(prog (a b)
  (setq a 10)
  (setq b 20)
  (plus a b))
(func getValue ()
  (prog ()
    (return 42)
    100))
(getValue)
(prog (x)
  (setq x 5)
  (setq x (times x 2))
  x)

# 16. Semantic errors: prog and return errors
(prog (1) (setq x 5) x)
(return 42)

# 17. Cond and while control structures
(cond (less 2 3) 'yes 'no)
(cond (greater 5 10) 'big)
(while true (break))
(prog (counter)
  (setq counter 0)
  (while (less counter 3)
    (setq counter (plus counter 1)))
  counter)


# 18. Semantic errors: cond and while type errors
(cond 42 'true 'false)
(cond (less 1 2))
(while true)
(while 1 (break))

# 19. Break inside while loops
(prog (count)
  (setq count 0)
  (while true
    (setq count (plus count 1))
    (cond (greater count 3) (break)))
  count)

# 20. Semantic errors: break usage errors
(break)
(plus 1 (break))

# 21. Eval function
(eval '(plus 2 3))
(eval 42)
(eval 'x)
(eval '(cond true 'evaluated 'skipped))

# 22. Semantic errors: eval type errors
(eval)
(eval true false)
(eval '(1 2 3))
(eval '(plus 1))

# 23. Recursion: factorial and Fibonacci
(func fact (n)
  (cond (less n 2)
    1
    (times n (fact (minus n 1)))))
(fact 5)
(func fib (n)
  (cond (less n 2)
    n
    (plus (fib (minus n 1)) (fib (minus n 2)))))
(fib 6)

# 24. Closures and higher-order functions
(prog ()
  (setq maker (lambda (x)
    (lambda (y) (plus x y))))
  (setq add5 (maker 5))
  (add5 10))
(prog ()
  (setq counter (lambda ()
    (prog (n)
      (setq n 0)
      (lambda ()
        (setq n (plus n 1))
        n))))
  (setq c (counter))
  (cons (c) (cons (c) (cons (c) '()))))

# 25. Argument evaluation order and side effects
(prog (a)
  (setq a 0)
  (plus (setq a (plus a 1))
        (setq a (plus a 2)))
  a)
(prog (x y)
  (setq x 1)
  (setq y 2)
  (times (setq x (times x 3))
         (setq y (times y 4))))

# 26. AST Optimization — Constant Folding
(times (plus 1 2) 4)
(divide 10 2)
(minus 10 3)
(setq x (plus 2 3))
(plus x 1)
(and true false)
(or false true)
(not false)
(less 2 5)
(equal 3 3)
(greater (plus 2 3) (minus 10 6))

# 27. AST Optimization — Remove Unused Variables
(setq x 10)
(setq y (plus 2 3))
(plus y 1)
(setq z 42)

# 28. AST Optimization — Remove Unused Variables with function call
(setq counter 0)
(func incCounter ()
    (setq counter (plus counter 1))
)
(incCounter)
counter

# 29. High-order functions: function argument
(func square (x)
    (plus x x)
)
(func applyTwice (f x)
    (prog ()
        (return (f (f x)))
    )
)
(applyTwice square 2)

# 30. High-order functions: function as argument
(func apply (f x)
    (f x)
)
(apply (lambda (y) (plus y 10)) 5)

# 31. High-order functions: return function
(func makeAdder (a)
    (lambda (b) (plus a b))
)
(setq add5 (makeAdder 5))
(add5 7)

# 32. High-order functions: lambda in lambda
((lambda (x)
      ((lambda (y)
         (plus x y)
      )
    3))
4)

# 33. High-order functions: function accepts a function and returns a new one
(func compose (f g)
    (lambda (x)
        (f (g x))
    )
)
(func inc (x) (plus x 1))
(func double (x) (plus x x))
(setq incThenDouble (compose double inc))
(incThenDouble 5)
